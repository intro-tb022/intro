---
math: true
---

{% assign tp = site.data.trabajos.TP2-2 %}
{% capture fecha %}{{tp.entrega | date: "%e/%m"}}{% endcapture %}

# TP2 - IntroDex

Nuevamente, vamos a terminar desarrollando un sistema que va a poder obrar de PokeDex con toda la info del mundo pókemon y donde además vamos a poder crear nuestros equipos, con los cuales, en un futuro más allá de esta materia, podrían pelear.
Va a contener 3 partes: BackEnd (BE), BackEnd con Base de Datos (BE con BD), FrontEnd (FE).
Ésta será la segunda parte enfocada en adaptar el BE para usar Base de Datos y modificar algunos endpoints para agregar cosas que serán necesarios a futuro.
Se recomienda seguir todas las recomendaciones y guías dadas en clase porque harán más fáciles los cambios requeridos para las siguientes partes.

## Temas a evaluar

- Git
- Trabajo en equipo
- Testing
- Desarrollo BackEnd (Framework: FastAPI)
- Base de Datos relacionales (SQLite)

## Glosario

- **Pokemon**: monstruo ficticio de la serie animada japonesa Pokemon. Son comunmente utilizados para enfrentarse en batallas entre si. Actualmente hay mas de mil Pokemones. Un clásico ejemplo es Pikachu. Considerar que no existe un unico Pikachu en el mundo, pueden haber infinitos.
- **Tipo**: uno de los atributos que puede tener un Pokemon. Hay un total de 18 tipos diferentes en Pokemon. Los Pokemones pueden tener hasta un máximo de 2 tipos. Definen la efectividad y resistencia de los ataques que afecten al Pokemon.
- **Estadística**: al igual que el tipo, las estadísticas son los atributos que tiene un Pokemon. Existen las estadísticas de Ataque (ATK), Defensa (DEF), HitPoints (HP), Ataque Especial (SPATK), Defensa Especial (SPDEF) y Velocidad (SPEED). Todos los Pokemones tienen distintas estadisticas base, pero por ejemplo todos los Pikachu tienen las mismas estadisticas base.
- **Habilidad**: efecto, usualmente beneficioso, que afecta a un Pokemon. Cada Pokemon tiene un pool de habilidades con las que puede existir, sin embargo, un Pokemon siempre tiene exactamente una Habilidad.

## Consigna

Vamos a continuar la parte 1 ya hecha, por lo que vamos a usar el mismo repositorio en el que veremos un PR con la actualización de la consigna para la Parte 2. Es por esto que no hay un nuevo Assignment con un nuevo link. Por si hay alguna complicación con la actualización de la consigna, la dejamos detallada por aquí para rápido acceso:

=============================
=============================

Ya terminado el primer "sprint" de trabajo debemos proceder con el siguiente: persistir la información que tenemos en bases de datos. Para ello podemos mergear el PR de parte_1 a main si nuestro corrector nos da el Approve necesario. De no tenerlo aún, mantener la rama para las correcciones necesarias y mergearla apenas esté aprobado.

## Parte 2

Vamos a utilizar el mismo backend que programamos en la parte anterior, por lo que vamos a actualizar el repositorio que ya tenemos. Pero repetiremos el modus operandi y crearemos una nueva rama para este nueva parte.

En esta parte 2, debemos refactorizar el código que tenemos para usar datos persistidos en una base de datos en lugar de obtenerlos/guardarlos de otra manera.

Para ello vamos a necesitar hacer todo lo siguiente:

- Crear la base de datos necesaria en SQLite
- Crear las migraciones pertinentes y las tablas necesarias para estructurar nuestros datos (al realizar los endpoints, vimos algunas posibles entidades a implementar)
- Ingestar los datos de los CSVs en la base de datos de SQLite en vez de en memoria.
- Adaptar la clase Database para que haga consultas a la base de datos
- Adaptar y agregar tests
- Corregir errores de la parte anterior
- Definir nuevos endpoints de ser necesarios

Las entidades **mínimas** que esperamos que existan en la base de datos son:

- Pokemon
- Movimiento
- Equipo
- Integrante

Sin embargo podrían ser útiles tener otras entidades como por ejemplo `MetodoDeAprendizaje` o demás.

## Endpoints

En esta parte 2 vamos a modificar todos los endpoints existentes que devuelvan listas de tamaño "desconocido" para agregarles Paginación siguiendo los lineamientos vistos en clase.

Además, vamos a agregar algunos endpoints más o algunos filtros nuevos a endpoints existentes, que serán detallados debajo.

### Filtrar pokemones

En esta instancia deberemos poder filtrar los pokemones por estadística mínima (mismo lógica que en el TP1) de la siguiente manera:
```
GET /api/pokemon?min_stat=450
```

### Filtrar movimientos

Al igual que a los pokemons, deberemos poder filtrar movimientos de la siguiente manera:
```
GET /api/movimiento?tipo=4
GET /api/movimiento?nombre_parcial=ido
```

La respuesta mostrará una lista que sólo va a contener movimientos que sean de ese `tipo` y/o que contengan el `nombre_parcial` dentro de su nombre.

### Listar tipos

```
GET /api/tipo
```
que devolverá para cada pokemon su ID, nombre, imagen y tipos:
```
[
	{
        "id": 1,
        "nombre": "Normal",
    },
	...
]
```


### Crear y actualizar un Integrante de un Equipo

A los integrantes de un equipo también se les deberá especificar sus estadísticas (o EVs): ser creados con ellas y poder editarlas.
Recordemos que las estadísticas son: ataque, defensa, ataque especial, defensa especial, puntos de golpe y velocidad.

Hay limitaciones en cuanto a las estadísticas que pueden ser asignadas:
- Todo pokemon tiene estadísticas base (ergo: todos los pikachu tienen las mismas estadísticas base de pikachu)
- Cada Integrante puede mejorar sus estadísticas base con EVs propias (si un pikachu entrena mucho su defensa, va a tener mejor defensa que otro pikachu que se enfocó en ataque)
- La estadística final de un Integrante es la sumatoria de las base y las especializadas (EVs).
- Cada estadística final particular no puede superar los 255 puntos.
- La cantidad de EVs totales disponibles para un integrante son 510 puntos.


## Flujo de trabajo en equipo

El flujo de trabajo esperado es el siguiente:

- Alumno 1 decide resolver el endpoint `Actualizar list_pokemons`
- Alumno 1 crea su rama de trabajo y realiza su trabajo, una vez listo pushea y realiza un PR.
- Alumno X revisa el PR de su compañero, dejando comentarios de ser necesario. En caso de que no haya comentarios, aprobar el PR.
- Alumno 1 revisa los comentarios de haberlos, los resuelve y realiza el paso anterior nuevamente. Y así hasta que el PR esté aprobado, momento en el cual el Alumno 1 lo mergea.

Sigue siendo requisito para la aprobación del trabajo práctico que cada integrante haya resuelto **al menos una de las tareas** y que haya revisado y aprobado **al menos un PR** de algun compañero. En caso de que un integrante no cumpla el requisito tendrá el trabajo desaprobado.

## Entrega

El trabajo se entregará a través de GH Classroom y del repositorio provisto. Se deberá crear una rama `parte2` y hacer un Pull Request a la rama `main`.

`main` **no debe tener ningún contenido más allá del proviste por el repositorio base y los archivos mergeados de la parte 1**. Todo el código debe ser escrito en la rama `parte2`. Con lo cual, todo su trabajo interno va a partir de `parte2`.

## Requisitos adicionales

Existen los mismos requisitos que en la parte 1.
Es decir, que se debe seguir usando `pipenv` y `black` y tener un coverage de al menos 75%.
Con la diferencia de que en esta instancia sí es necesario persistir la data y que sobreviva a distintas corridas del sistema.

Además se deberá desarrollar con la base de datos SQLite y el framework de Python correspondiente, SQLModel. Además, se deberá utilizar Alembic para manejar las migraciones.

Nuevamente recomendamos mantener buena calidad de código e implementar buenas prácticas.
