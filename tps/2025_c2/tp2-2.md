---
math: true
---

{% assign tp = site.data.trabajos.TP2-2 %}
{% capture fecha %}{{tp.entrega | date: "%e/%m"}}{% endcapture %}

# TP2 - IntroDex

Nuevamente, vamos a terminar desarrollando un sistema que va a poder obrar de PokeDex con toda la info del mundo pókemon y donde además vamos a poder crear nuestros equipos, con los cuales, en un futuro más allá de esta materia, podrían pelear.
Va a contener 3 partes: BackEnd (BE), BackEnd con Base de Datos (BE con BD), FrontEnd (FE).
Ésta será la segunda parte enfocada en adaptar el BE para usar Base de Datos y modificar algunos endpoints para agregar cosas que serán necesarios a futuro.
Se recomienda seguir todas las recomendaciones y guías dadas en clase porque harán más fáciles los cambios requeridos para las siguientes partes.

## Temas a evaluar

- Git
- Trabajo en equipo
- Testing (Pytest)
- Desarrollo BackEnd (Framework: FastAPI)
- Base de Datos relacionales (SQLite)

## Glosario

- **Pokemon**: monstruo ficticio de la serie animada japonesa Pokemon. Son comunmente utilizados para enfrentarse en batallas entre si. Actualmente hay mas de mil Pokemones. Un clásico ejemplo es Pikachu. Considerar que no existe un unico Pikachu en el mundo, pueden haber infinitos.
- **Tipo**: uno de los atributos que puede tener un Pokemon. Hay un total de 18 tipos diferentes en Pokemon. Los Pokemones pueden tener hasta un máximo de 2 tipos. Definen la efectividad y resistencia de los ataques que afecten al Pokemon.
- **Estadística**: al igual que el tipo, las estadísticas son los atributos que tiene un Pokemon. Existen las estadísticas de Ataque (ATK), Defensa (DEF), HitPoints (HP), Ataque Especial (SPATK), Defensa Especial (SPDEF) y Velocidad (SPEED). Todos los Pokemones tienen distintas estadisticas base, pero por ejemplo todos los Pikachu tienen las mismas estadisticas base.
- **Habilidad**: efecto, usualmente beneficioso, que afecta a un Pokemon. Cada Pokemon tiene un pool de habilidades con las que puede existir, sin embargo, un Pokemon siempre tiene exactamente una Habilidad.

## Consigna

Vamos a continuar la parte 1 ya hecha, por lo que vamos a usar el mismo repositorio en el que veremos un PR con la actualización de la consigna para la Parte 2. Es por esto que no hay un nuevo Assignment con un nuevo link. Por si hay alguna complicación con la actualización de la consigna, la dejamos detallada por aquí para rápido acceso:

=============================
=============================

Ya terminado el primer "sprint" de trabajo debemos proceder con el siguiente: persistir la información que tenemos en bases de datos. Para ello podemos mergear el PR de parte_1 a main si nuestro corrector nos da el Approve necesario. De no tenerlo aún, mantener la rama para las correcciones necesarias y mergearla apenas esté aprobado.

## Parte 2

Vamos a utilizar el mismo backend que programamos en la parte anterior, por lo que vamos a actualizar el repositorio que ya tenemos. Pero repetiremos el modus operandi y crearemos una nueva rama para este nueva parte.

En esta parte 2, debemos refactorizar el código que tenemos para usar datos persistidos en una base de datos en lugar de obtenerlos/guardarlos de otra manera.

Para ello vamos a necesitar hacer todo lo siguiente:

- Crear la base de datos necesaria en SQLite
- Crear las migraciones pertinentes y las tablas necesarias para estructurar nuestros datos
- Ingestar los datos de los CSVs en la base de datos de SQLite en vez de en memoria.
- Adaptar las clases Database para que hagan consultas a la base de datos
- Adaptar y agregar tests
- Definir nuevos endpoints de ser necesarios
- Corregir errores y mejoras propuestas de la parte anterior

Las entidades **mínimas** que esperamos que existan en la base de datos son:

- Pokemon
- Movimiento
- Equipo
- Integrante

Sin embargo podrían ser útiles tener otras entidades como por ejemplo `MetodoDeAprendizaje`, `EstadisticaPokemon` o demás.


## Funcionalidades nuevas

Además, vamos a agregar algunas cosas nuevas a lo que ya teníamos hasta el momento. Esta nueva funcionalidad se se detalla a continuación.

### Paginación

En esta segunda parte vamos a modificar todos los endpoints existentes que devuelvan listas de tamaño "desconocido" para agregarles Paginación siguiendo los lineamientos vistos en clase (usando limit y offset).

### Filtrar pokemones

Además de los filtros ya implementados en la primer parte, en esta instancia deberemos poder filtrar los pokemones por estadística mínima de la siguiente manera:

```
GET /api/pokemon?min_stat=450
```

### Filtrar movimientos

Al igual que a los Pokemon, deberemos poder filtrar movimientos de la siguiente manera:
```
GET /api/movimiento?tipo=4
GET /api/movimiento?nombre_parcial=ido
```

La respuesta mostrará una lista que sólo va a contener movimientos que sean de ese `tipo` y/o que contengan el `nombre_parcial` dentro de su nombre.

### Listar tipos

Se agregará un nuevo endpoint para listar los tipos posibles (será útil para la tercer parte)

```
GET /api/tipo
```
que devolverá para cada pokemon su ID, nombre, imagen y tipos:
```
[
	{
        "id": 1,
        "nombre": "Normal",
    },
	...
]
```


## Flujo de trabajo en equipo

El flujo de trabajo esperado es el siguiente:

- Alumno 1 decide resolver el endpoint `Actualizar list_pokemons`
- Alumno 1 crea su rama de trabajo y realiza su trabajo, una vez listo pushea y realiza un PR.
- Alumno X revisa el PR de su compañero, dejando comentarios de ser necesario. En caso de que no haya comentarios, aprobar el PR.
- Alumno 1 revisa los comentarios de haberlos, los resuelve y realiza el paso anterior nuevamente. Y así hasta que el PR esté aprobado, momento en el cual el Alumno 1 lo mergea.

Sigue siendo requisito para la aprobación del trabajo práctico que cada integrante haya resuelto **al menos una de las tareas** y que haya revisado y aprobado **al menos un PR** de algun compañero. En caso de que un integrante no cumpla el requisito tendrá el trabajo desaprobado.

## Entrega

El trabajo se entregará a través de GH Classroom y del repositorio provisto para la parte 1. Se deberá crear una rama `parte2` y hacer un Pull Request a la rama `main`.

`main` **no debe tener ningún contenido más allá del provisto por el repositorio base y los archivos mergeados de la parte 1**. Todo el código debe ser escrito en la rama `parte2`. Con lo cual, todo su trabajo interno va a partir de `parte2`.

## Requisitos adicionales

Existen los mismos requisitos que en la parte 1 con la diferencia de que en esta instancia sí es necesario persistir los datos y que sobreviva a distintas corridas del sistema.

Adicionalmente se deberá desarrollar usando el framework SQLModel para soportar una base de datos de SQLite usando migraciones.

Se deberá utilizar Alembic para manejar las migraciones.

Nuevamente recomendamos mantener buena calidad de código e implementar buenas prácticas de programación.
