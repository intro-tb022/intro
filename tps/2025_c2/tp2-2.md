---
math: true
---

{% assign tp = site.data.trabajos.TP2-2 %}
{% capture fecha %}{{tp.entrega | date: "%e/%m"}}{% endcapture %}

# TP2 - IntroDex

Nuevamente, vamos a terminar desarrollando un sistema que va a poder obrar de PokeDex con toda la info del mundo pókemon y donde además vamos a poder crear nuestros equipos, con los cuales, en un futuro más allá de esta materia, podrían pelear.
Va a contener 3 partes: BackEnd (BE), BackEnd con Base de Datos (BE con BD), FrontEnd (FE).
Ésta será la segunda parte enfocada en adaptar el BE para usar Base de Datos y modificar algunos endpoints para agregar cosas que serán necesarios a futuro.
Se recomienda seguir todas las recomendaciones y guías dadas en clase porque harán más fáciles los cambios requeridos para las siguientes partes.

## Temas a evaluar

- Git
- Trabajo en equipo
- Testing (Pytest)
- Desarrollo BackEnd (Framework: FastAPI)
- Base de Datos relacionales (SQLite)

## Glosario

- Equipo Pokemon: Un equipo Pokemon es un grupo de pokemones de entre 1 y 6 integrantes. Puede tener al mismo pokemon repetido muchas veces.
- Generacion: Los juegos de Pokemon llevan mucho tiempo lanzandose y cada nuevo grupo de Pokemones sale en nuevos juegos que conforman una Generacion. Es decir, las entregas de ciertos juegos forman parte de cierta generacion del 1 al 9. Por ejemplo, la Generacion 3 introdujo, entre otros, a los juegos de Pokemon Ruby, Zafiro y Esmeralda, asi como nuevos Pokemon como Metagross.
- Movimiento: Es la ejecucion de una accion en combate de un Pokemon. Cada Pokemon sabe entre 1 y 4 movimientos, pudiendo olvidar uno para reemplazarlo por otro.
- Grupo de Huevo: Los pokemones para reproducirse ponen huevos. Un grupo de huevos son aquellos pokemones que son "compatibles entre si" para reproducirse.
- EVs: Son especializaciones de estadísticas para un Pokemon. Todos los pokemones tienen un máximo de 510 EVs para mejorar sus estadísticas y pueden asignarsele un máximo de 255 por estadística.

## Consigna
Ya terminado el primer "sprint" de trabajo debemos proceder con el siguiente: persistir la información que tenemos en bases de datos. Para ello podemos mergear el PR de parte_1 a main si nuestro corrector nos da el Approve necesario. De no tenerlo aún, mantener la rama para las correcciones necesarias y mergearla apenas esté aprobado.

## Parte 2

Vamos a utilizar el mismo backend que programamos en la parte anterior, por lo que vamos a actualizar el repositorio que ya tenemos. Pero repetiremos el modus operandi y crearemos una nueva rama para este nueva parte.

En esta parte 2, debemos refactorizar el código que tenemos para usar datos persistidos en una base de datos en lugar de obtenerlos/guardarlos de otra manera.

Para ello vamos a necesitar hacer todo lo siguiente:

- Crear la base de datos necesaria en SQLite
- Crear las migraciones pertinentes y las tablas necesarias para estructurar nuestros datos
- Ingestar los datos de los CSVs en la base de datos de SQLite en vez de en memoria.
- Adaptar las clases Database para que hagan consultas a la base de datos
- Adaptar y agregar tests
- Definir nuevos endpoints de ser necesarios
- Corregir errores y mejoras propuestas de la parte anterior

Las entidades **mínimas** que esperamos que existan en la base de datos son:

- Pokemon
- Movimiento
- Equipo
- Integrante

Sin embargo podrían ser útiles tener otras entidades como por ejemplo `MetodoDeAprendizaje`, `EstadisticaPokemon` o demás.


## Funcionalidades nuevas

Además, vamos a agregar algunas cosas nuevas a lo que ya teníamos hasta el momento. Esta nueva funcionalidad se se detalla a continuación.

### Paginación

En esta segunda parte vamos a modificar todos los endpoints existentes que devuelvan listas de tamaño "desconocido" para agregarles Paginación siguiendo los lineamientos vistos en clase (usando limit y offset).

### Filtrar pokemones

Además de los filtros ya implementados en la primer parte, en esta instancia deberemos poder filtrar los pokemones por estadística mínima de la siguiente manera:

```
GET /api/pokemon?min_stat=450
```

### Filtrar movimientos

Al igual que a los Pokemon, deberemos poder filtrar movimientos de la siguiente manera:
```
GET /api/movimiento?tipo=4
GET /api/movimiento?nombre_parcial=ido
```

La respuesta mostrará una lista que sólo va a contener movimientos que sean de ese `tipo` y/o que contengan el `nombre_parcial` dentro de su nombre.

### Listar tipos

Se agregará un nuevo endpoint para listar los tipos posibles (será útil para la tercer parte)

```
GET /api/tipo
```
que devolverá para cada pokemon su ID, nombre, imagen y tipos:
```
[
	{
        "id": 1,
        "nombre": "Normal",
    },
	...
]
```


## Flujo de trabajo en equipo

El flujo de trabajo esperado es el siguiente:

- Alumno 1 decide resolver el endpoint `Actualizar list_pokemons`
- Alumno 1 crea su rama de trabajo y realiza su trabajo, una vez listo pushea y realiza un PR.
- Alumno X revisa el PR de su compañero, dejando comentarios de ser necesario. En caso de que no haya comentarios, aprobar el PR.
- Alumno 1 revisa los comentarios de haberlos, los resuelve y realiza el paso anterior nuevamente. Y así hasta que el PR esté aprobado, momento en el cual el Alumno 1 lo mergea.

Sigue siendo requisito para la aprobación del trabajo práctico que cada integrante haya resuelto **al menos una de las tareas** y que haya revisado y aprobado **al menos un PR** de algun compañero. En caso de que un integrante no cumpla el requisito tendrá el trabajo desaprobado.

## Entrega

El trabajo se entregará a través de GH Classroom y del repositorio provisto para la parte 1. Se deberá crear una rama `parte2` y hacer un Pull Request a la rama `main`.

`main` **no debe tener ningún contenido más allá del provisto por el repositorio base y los archivos mergeados de la parte 1**. Todo el código debe ser escrito en la rama `parte2`. Con lo cual, todo su trabajo interno va a partir de `parte2`.

## Requisitos adicionales

Existen los mismos requisitos que en la parte 1 con la diferencia de que en esta instancia sí es necesario persistir los datos y que sobreviva a distintas corridas del sistema.

Adicionalmente se deberá desarrollar usando el framework SQLModel para soportar una base de datos de SQLite usando migraciones.

Se deberá utilizar Alembic para manejar las migraciones.

Nuevamente recomendamos mantener buena calidad de código e implementar buenas prácticas de programación.
